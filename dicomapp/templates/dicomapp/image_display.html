



<!DOCTYPE html> 
<html lang="en">
{% load static %}
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Images from ZIP</title>
    
    <!-- Bootstrap CDN for dropdown -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Bootstrap Icons for zoom icon -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">
    
    <!-- CornerstoneJS CDN -->
    <script src="https://unpkg.com/cornerstone-core"></script>
    <script src="https://unpkg.com/cornerstone-wado-image-loader"></script>
    <!-- DICOM Parser -->
    <script src="https://unpkg.com/dicom-parser"></script>
    <style>
        /* Hover effect for the entire controls-right container */
        

        /* Hover effect for zoom, ruler, rotate, and download containers */
        .zoom-container:hover,
        .ruler-container:hover,
        .rotate-container:hover,
        .download-container:hover {
            background-color: #2a1b75; /* Subtle dark background on hover */
            transform: scale(1.05); /* Slight zoom effect for interaction */
            transition: background-color 0.3s ease, transform 0.2s ease; /* Smooth hover effect */
        }

        /* Blinking animation for buttons */
        {% comment %} @keyframes blink {
            0% {
                background-color: #1c0edfff;
            }
            50% {
                background-color: #1c0edfff; /* Highlighted color */
            }
            100% {
                background-color: #1c0edfff;
            }
        } {% endcomment %}

        /* Dropdown menu items styling */
        .dropdown-menu {
            border-radius: 5px;
            padding: 0;
            background-color: #6e7c83; /* Dropdown menu background color */
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            font-size: 14px;
            color: #ffffff;
            text-decoration: none;
        }

        .dropdown-item i {
            font-size: 18px;
            margin-right: 10px;
            transition: transform 0.2s ease-in-out, color 0.3s ease; /* Smooth transition */
        }

        /* Dropdown item hover effect */
        .dropdown-item:hover {
            background-color: #001d1917; /* Darker background for menu items on hover */
            color: white;
        }

        .dropdown-item:active {
            background-color: #6e7c83; /* Same color on active state */
        }

        /* Transition effect for icons */
        .bi {
            transition: transform 0.2s ease-in-out;
        }

        {% comment %} .zoom-container:hover .bi,
        .ruler-container:hover .bi,
        .rotate-container:hover .bi,
        .download-container:hover .bi {
            transform: scale(1.1); /* Slightly enlarge the icon */
        } {% endcomment %}

        /* Dropdown item icon hover effect */
        .dropdown-item:hover i {
            transform: scale(1.1); /* Slightly enlarge the icon in dropdown */
            
        }
        .thumbnails .thumbnail-container {
        transition: 
            background-color 0.2s ease,
            transform          0.2s ease,
            box-shadow         0.2s ease;
        }

        /* Hover state: pop out, subtle highlight & shadow */
        .thumbnails .thumbnail-container:hover {
            background-color: rgba(255, 255, 255, 0.1); /* tweak α to taste */
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        /* Also ease the image itself */
        .thumbnails .thumbnail-container img {
            transition: transform 0.2s ease;
        }

        /* Slight extra zoom on the image */
            .thumbnails .thumbnail-container:hover img {
        transform: scale(1.02);
        }
        .thumbnails .thumbnail-container {
            transition: background-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
        }
        .thumbnails .thumbnail-container.active {
            background-color: #48465cff; /* Blue background for active (selected) thumbnail */
            transform: scale(1.1); /* Slightly enlarge the selected thumbnail */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        .thumbnails .thumbnail-container:hover img {
            transform: scale(1.02);
        }
        /* Icon styling */
        .zoom-container i,
        .ruler-container i,
        .rotate-container i,
        .download-container i {
            font-size: 30px;
            cursor: pointer;
            transition: transform 0.2s ease, color 0.3s ease;
            color: aliceblue;
        }
        /* Icon hover effect */
        .zoom-container:hover i,
        .ruler-container:hover i,
        .rotate-container:hover i,
        .download-container:hover i {
            transform: scale(1.1); /* Slightly enlarge the icon */
            
        }
        .zoom-container span,
        .ruler-container span,
        .rotate-container span,
        .download-container span {
            font-size: 13px;
            line-height: -5;
            color: aliceblue;
        }


    </style>

</head>
<body>
    
    <div class="controls-container" style="display: flex; gap: 20px; justify-content: flex-end;background: linear-gradient(to bottom, #3123b4 0%, #000000 120%); ;padding: 10px; ">
       
        
        
        <!-- Other content (this stays on the left side) -->
        
        <div class="controls-right" style="display: flex; gap: 30px; align-items: center;">
            <!-- Zoom Icon and Dropdown -->
            <div class="zoom-container" style="padding: 4px; border-radius: 5px; width: 60px; height: 60px; transition: background-color 0.3s;color: aliceblue;">
                <i class="bi bi-zoom-in" style="font-size: 30px; cursor: pointer; position: relative; right: -7px;" onclick="toggleZoomMenu()"></i>
                <span style="font-size: 13px;  line-height: -5;padding: 7px;">Zoom</span>

                <!-- Zoom Dropdown Menu -->
                <div id="zoom-menu" class="dropdown-menu" style="display: none; position: absolute; z-index: 1000; margin-top: 10px; background: linear-gradient(135deg, #3123b4ff, #6a4af9); border-radius: 5px; padding: 0;">
                    
                    <a class="dropdown-item" href="#" onclick="setZoom100();">
                        <i class="bi bi-zoom-in" style="font-size: 18px; margin-right: 8px;"></i>100%
                    </a>
                    <a class="dropdown-item" href="#" onclick="setZoom200();">
                        <i class="bi bi-zoom-in" style="font-size: 18px; margin-right: 8px;"></i>200%
                    </a>
                    <a class="dropdown-item" href="#" onclick="setZoom400();">
                        <i class="bi bi-zoom-in" style="font-size: 18px; margin-right: 8px;"></i>400%
                    </a>
                    <a class="dropdown-item" href="#" onclick="setZoom800();">
                        <i class="bi bi-zoom-in" style="font-size: 18px; margin-right: 8px;"></i>800%
                    </a>
                    <a class="dropdown-item" href="#" onclick="zoomIn()">
                        <i class="bi bi-plus-circle " style="font-size: 18px; margin-right: 8px;"></i>Zoom In
                    </a>
                    <a class="dropdown-item" href="#" onclick="zoomOut()">
                        <i class="bi bi-dash-circle " style="font-size: 18px; margin-right: 8px;"></i>Zoom Out
                    </a>
                </div>
            </div>

            <!-- Ruler Icon and Dropdown Menu for Drawing/Erasing Lines -->
            <div class="ruler-container" style=" padding: 4px; border-radius: 5px; width: 60px; height: 60px; transition: background-color 0.3s;color: aliceblue;">
                <i class="bi bi-rulers" style="font-size: 30px; cursor: pointer; position: relative; right: -7px;" onclick="toggleRulerMenu()"></i>
                <span style="font-size: 13px;  line-height: -5;">Anotation</span>
                
                <!-- Ruler Dropdown Menu -->
                <div id="ruler-menu" class="dropdown-menu" style="display: none; position: absolute; z-index: 1000; margin-top: 10px;background: linear-gradient(135deg, #3123b4ff, #6a4af9);">
                    <a class="dropdown-item" href="#" onclick="setMode('arrow')"><i class="bi bi-arrow-up-right me-2"></i>Arrow</a>
                    <a class="dropdown-item" href="#" onclick="setMode('draw')"><i class="bi bi-arrow-left-right me-2"></i>Distance</a>
                    <a class="dropdown-item" href="#" onclick="setMode('ellipse')"><i class="bi bi-circle me-2"></i>Ellipse</a>
                    <a class="dropdown-item" href="#" onclick="setMode('rectangle')"><i class="bi bi-square me-2"></i>Rectangle</a>
                    <a class="dropdown-item" href="#" onclick="setMode('eraseAll')"><i class="bi bi-trash me-2"></i>Erase All Lines</a>
                </div>
            </div>

            <!-- Rotate Icon and Dropdown -->
            <div class="rotate-container" style=" padding: 4px; border-radius: 5px; width: 60px; height: 60px; transition: background-color 0.3s;color: aliceblue;">
                <i class="bi bi-arrow-repeat" style="font-size: 30px; cursor: pointer; position: relative; right: -7px;" onclick="toggleRotateMenu()"></i>
                <span style="font-size: 13px;  line-height: -5;padding: 7px;">Rotate</span>
                
                <!-- Rotate Dropdown Menu -->
                <div id="rotate-menu" class="dropdown-menu" style="display: none; position: relative; z-index: 1000; margin-top: 10px; float: right;background: linear-gradient(135deg, #3123b4ff, #6a4af9);">
                    <a class="dropdown-item" href="#" onclick="rotateImageAnticlockwise()"><i class="bi bi-arrow-counterclockwise me-2"></i>Rotate 90° CCW</a>
                    <a class="dropdown-item" href="#" onclick="rotateImage()"><i class="bi bi-arrow-clockwise me-2"></i>Rotate 90° CW</a>
                    <a class="dropdown-item" href="#" onclick="rotateImage180()"><i class="bi bi-arrow-down-up me-2"></i>Rotate 180°</a>
                    <a class="dropdown-item" href="#" onclick="flipHorizontal()"><i class="bi bi-arrow-left-right me-2"></i>Flip Horizontal</a>
                    <a class="dropdown-item" href="#" onclick="flipVertical()"><i class="bi bi-arrow-down-up"></i>Flip Vertical</a>
                </div>
            </div>

            <!-- Download Icon -->
            <div class="download-container" style=" padding: 4px; border-radius: 5px; width: 60px; height: 60px; transition: background-color 0.3s;color: aliceblue;">
                <i class="bi bi-download" style="font-size: 30px; cursor: pointer; position: relative; right: -7px;" onclick="downloadImage()"></i>
                <span style="font-size: 13px;  line-height: -5;">Download</span>
                
            </div>
        </div>

    </div>


    <!-- DICOM Thumbnails Container -->
    <div class="dicom-thumbnails" style="display: flex;   background-color: white;flex-direction: column; height: 89vh;">

        <!-- Image Thumbnails Section -->
        
        <div class="thumbnails" style="display: flex; flex-direction: row; gap: 10px;width: 100%;height: 100px; background: linear-gradient(to bottom, #000000  -20%, #3123b4 120%); ">
            {% for image in images %}
                <div class="thumbnail-container" id="thumbnail-container-{{ forloop.counter }}" style="position: relative; display: block; width: 10%; height: 100px;  padding: 5px 14px 5px 14px; margin: 0;background-color: transparent;">

                    <img src="/media/{{ image }}" class="thumbnail" style="width: 100%; height: 100%;object-fit: cover; margin: 0;  cursor: pointer;" id="thumbnail-{{ forloop.counter }}" onclick="changeImage('/media/{{ image }}', 'thumbnail-{{ forloop.counter }}')">
                </div>
            {% endfor %}
        </div>

        <!-- Controls Container: Zoom and Ruler Icons -->
        
        <!-- Main Image Section -->
        <div class="main-image" style=" display: flex; justify-content: center; align-items: center;height: calc(100vh - 70px);background-color: #1e1e1e; background-size: cover; background-position: center center; flex-grow: 1; overflow: hidden;">
            <div id="image-container" style="position: relative; width: auto; height: auto;">
            
                <img id="main-image" src=""  style="width:700px; height: auto;box-shadow: 0px 0px 2px; border-radius: 4px;">
                <canvas id="canvas" style="position: absolute; top: 0; left: 0;cursor: default;"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Global variables for drawing and mode selection
        var drawMode = 'none'; // 'draw' or 'erase'
        var canvas = document.getElementById('canvas');
        var ctx = canvas.getContext('2d');
        var mainImageElement = document.getElementById('main-image');
        var imageContainer = document.getElementById('image-container');
        var imageElement;
        var startX, startY, endX, endY;
        var currentLine;
        var lines = []; // Array to store drawn lines
        var ellipses = []; // Array to store ellipses
        var eraseMode = false; // Track whether erase mode is active
        var rectangles = []; // Array to store drawn rectangles
        var selectedRectangle = null; // Currently selected rectangle for resizing
        var currentZoomLevel = 100; // Initial zoom level set to 100%
        var currentRotation = 0; 
        let isFlipped = false;
        let isFlippedVertically = false;
        let isEllipseAdded = false;
        var polygonPoints = []; // Store points for polygon
        var polygons = []; // Store completed polygons
        var isDrawingPolygon = false; // Track whether polygon drawing is active

        // Adjust canvas size to match the image size on load
        mainImageElement.onload = function() {
            canvas.width = mainImageElement.width; // Set canvas width to image width
            canvas.height = mainImageElement.height; // Set canvas height to image height
            // Draw the image on the canvas
            ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height);
            redrawCanvas(); 
        };


        // Set up image loading with Cornerstone
        cornerstoneWADOImageLoader.external.cornerstone = cornerstone;
        cornerstoneWADOImageLoader.external.dicomParser = dicomParser;

        {% comment %} let selectedThumbnail = null; {% endcomment %}

        {% comment %} function changeImage(imageSrc, thumbnailId) {
            console.log(`thumbnailId received: ${thumbnailId}`); // Log the thumbnailId

            var mainImageElement = document.getElementById('main-image');
            console.log(`Changing image source to: ${imageSrc}`);
            mainImageElement.src = imageSrc + "?t=" + new Date().getTime();
            loadImage(imageSrc); // Reload image with Cornerstone

            // Check if a thumbnail is already selected
            if (selectedThumbnail) {
                console.log(`Removing active styles from: ${selectedThumbnail.id}`);
                // Remove active styles from the previously selected thumbnail
                selectedThumbnail.style.border = "none";
                selectedThumbnail.style.backgroundColor = ""; // Reset background color
            }

            // Set the new selected thumbnail
            selectedThumbnail = document.getElementById(thumbnailId);
            console.log(`Selected new thumbnail with ID: ${selectedThumbnail.id}`);

            // Apply active styles to the newly selected thumbnail
            selectedThumbnail.style.border = "5px solid blue"; // Set blue border
            selectedThumbnail.style.backgroundColor = "#4CAF50"; // Set background color to green (for selected thumbnail)
            console.log(`Applied styles to selected thumbnail: ${selectedThumbnail.id}`); // Confirm style application
        } {% endcomment %}

        function changeImage(imageSrc, thumbnailId) {
            console.log(`thumbnailId received: ${thumbnailId}`); // Log the thumbnailId

            var mainImageElement = document.getElementById('main-image');
            console.log(`Changing image source to: ${imageSrc}`);
            mainImageElement.src = imageSrc + "?t=" + new Date().getTime();

            var clickedThumbnail = document.getElementById(thumbnailId);
            console.log(`Selected new thumbnail with ID: ${clickedThumbnail.id}`);

            // Get the parent container of the clicked thumbnail (the div with class "thumbnail-container")
            var clickedThumbnailContainer = clickedThumbnail.parentElement; // This will be the div with class "thumbnail-container"

            // Remove active background color from all thumbnail containers
            var thumbnails = document.querySelectorAll('.thumbnail-container');
            thumbnails.forEach(function(thumbnail) {
                thumbnail.style.backgroundColor = ""; // Reset background color
            });

            // Apply active background color to the newly selected thumbnail container
             // Set background color to green (for selected thumbnail)
            console.log(`Applied background color to selected thumbnail: ${clickedThumbnail.id}`);

            loadImage(imageSrc); // Reload image with Cornerstone
        }


        // Load image into Cornerstone
        function loadImage(imageSrc) {
            cornerstone.loadImage(imageSrc).then(function(image) {
                imageElement = image;
                cornerstone.displayImage(imageContainer, image);
                canvas.width = imageElement.width;
                canvas.height = imageElement.height;
                redrawCanvas(); // Redraw the lines for the new image
            });
        }

        // Set the mode (draw or erase)
        function setMode(mode) {
            drawMode = mode;
            if (mode === 'draw') {
                alert("Drawing mode enabled");
                canvas.style.cursor = "crosshair"; // Show crosshair cursor for drawing
                eraseMode = false; // Disable erasing lines
            } else if (mode === 'erase') {
                alert("Erase mode enabled");
                eraseMode = true; // Enable erasing lines
                canvas.style.cursor = "pointer"; // Show pointer for erase mode
            } else if (mode === 'eraseAll') {
                alert("Erase All Lines");
                eraseAllLines(); // Erase all lines when selected
            } else if (mode === 'arrow') {
                alert("Arrow mode enabled");
                canvas.style.cursor = "pointer"; // Show pointer for drawing arrows
                // Reset the drawing state when switching to arrow mode
                startX = null;
                startY = null;
            } else if (mode === 'ellipse') {
                alert("Ellipse mode enabled");
                console.log("Ellipse mode enabled");
                canvas.style.cursor = "crosshair";
                
            } else if (mode === 'rectangle') {
                alert("Rectangle mode enabled");
                canvas.style.cursor = "crosshair"; // Crosshair for rectangle drawing
                eraseMode = false; // Disable erasing lines
            } else if (mode === 'polygon') {
                alert("Polygon drawing mode enabled");
                isDrawingPolygon = true;
                polygonPoints = []; // Reset points for new polygon
                canvas.style.cursor = "crosshair"; // Show crosshair for polygon drawing

            } else {
                // Default cursor style when no mode is selected
                canvas.style.cursor = "default";
                eraseMode = false;
                isDrawingPolygon = false;
            }
            var menu = document.getElementById("ruler-menu");
            menu.style.display = "none"; // Close the dropdown
        }

        // Clear the canvas (erase all lines)
        function clearCanvas() {
            console.log("Clearing canvas...");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
           
            redrawCanvas(); // Ensure canvas is completely cleared
        }
        // Erase all lines
        function eraseAllLines() {
            console.log("Erasing all lines...");
            console.log("Lines array before clearing:", lines);
            console.log("Ellipses array before clearing:", ellipses);
            console.log("Rectangles array before clearing:", rectangles);
            lines = []; // Clear lines array
            ellipses = []; // Clear ellipses array
            rectangles = []; // Clear rectangles array (Ensure it's cleared)
            distanceMarkers = [];
            console.log("Lines array after clearing:", lines);
            console.log("Ellipses array after clearing:", ellipses);
            console.log("Rectangles array after clearing:", rectangles);
            
            // Redraw the image and reset the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear the canvas
            console.log("Canvas cleared.");
            ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height); // Redraw the image
            redrawCanvas(); // Redraw all lines and ellipses after clearing
        }

        // Drawing logic on mouse events
        canvas.addEventListener('mousedown', function(event) {
            if (drawMode === 'draw' && !eraseMode) {
                startX = event.offsetX;
                startY = event.offsetY;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                canvas.addEventListener('mousemove', drawLine);
            } else if (eraseMode) {
                eraseSpecificLine(event); // If erase mode is active, check for line to erase
            } else if (drawMode === 'arrow') {
                // Ensure startX and startY are reset before starting to draw a new arrow
                if (startX === null && startY === null) {
                    startX = event.offsetX;
                    startY = event.offsetY;
                }
            } else if (drawMode === 'ellipse') {
                // Ellipse Drawing Mode
               
                startX = event.offsetX;
                startY = event.offsetY;
                ctx.beginPath(); // Start the ellipse drawing
                console.log("Ellipse drawing started at: ", startX, startY);
            } else if (drawMode === 'rectangle' && !eraseMode) {
                // Rectangle Drawing Mode
                startX = event.offsetX;
                startY = event.offsetY;
                selectedRectangle = { startX, startY, endX: startX, endY: startY, resizing: false };
                ctx.beginPath(); // Start rectangle drawing
            } else if (isDrawingPolygon) {
                var x = event.offsetX;
                var y = event.offsetY;
                polygonPoints.push({ x: x, y: y }); // Store the point for the polygon
                drawPolygonPreview(); // Draw the polygon as the user clicks
                drawPoint(x, y); // Draw the point as a circle
            }
        });
        canvas.addEventListener('mousemove', function(event) {
            if (drawMode === 'rectangle' && startX && startY && !selectedRectangle.resizing) {
                // Redraw everything and only update the current rectangle being drawn
                

                // Draw rectangle dynamically as the mouse moves without clearing the canvas
                ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height); // Redraw the image
                redrawCanvas(); // Redraw all existing rectangles, lines, and other elements

                // Calculate rectangle width and height based on mouse position
                let rectWidth = event.offsetX - selectedRectangle.startX;
                let rectHeight = event.offsetY - selectedRectangle.startY;

                // Draw the rectangle dynamically
                ctx.strokeStyle = 'red';
                ctx.setLineDash([]); // Solid line
                ctx.strokeRect(selectedRectangle.startX, selectedRectangle.startY, rectWidth, rectHeight); // Draw rectangle dynamically
            }
            // Logic to dynamically draw ellipse while mouse is moving
            if (drawMode === 'ellipse' && startX && startY) {
                endX = event.offsetX;
                endY = event.offsetY;

                // Clear canvas and redraw all elements before redrawing ellipses
                ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear the canvas
                ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height); // Redraw the base image
                redrawCanvas(); // Redraw all existing elements (lines, rectangles, ellipses)

                // Draw all existing ellipses with their data
                for (let i = 0; i < ellipses.length; i++) {
                    let ellipse = ellipses[i];
                    drawEllipseWithData(ellipse.startX, ellipse.startY, ellipse.endX, ellipse.endY, ellipse.mean, ellipse.sd, ellipse.max, ellipse.min, ellipse.area);
                }

                // Draw the new ellipse dynamically
                drawEllipseWithData(startX, startY, endX, endY); // Update the ellipse with new data
            }
        });

        // Handle double-click to close the polygon
        canvas.addEventListener('dblclick', function(event) {
            if (isDrawingPolygon && polygonPoints.length > 2) {
                polygons.push([...polygonPoints]); // Save the completed polygon
                drawPolygon(polygonPoints); // Draw the final polygon
                calculatePolygonArea(polygonPoints); // Calculate and display area
                polygonPoints = []; // Reset for next polygon
                isDrawingPolygon = false; // Disable polygon drawing
            }
        });

        canvas.addEventListener('mouseup', function(event) {
            if (drawMode === 'draw' && !eraseMode) {
                endX = event.offsetX;
                endY = event.offsetY;
                drawLine(event);
                calculateDistance(startX, startY, endX, endY); // Calculate distance between the points
                lines.push({ startX, startY, endX, endY }); // Store the line
                canvas.removeEventListener('mousemove', drawLine);
                
            }
            // Handle drawing arrow
            else if (drawMode === 'arrow') {
                endX = event.offsetX;
                endY = event.offsetY;
                drawDashedArrow(startX, startY, endX, endY);
                lines.push({ startX, startY, endX, endY, type: 'arrow' }); // Store arrow
                startX = null; // Reset startX after drawing arrow
                startY = null; // Reset startY after drawing arrow
            } else if (drawMode === 'ellipse') {

                endX = event.offsetX;
                endY = event.offsetY;

                // Calculate ellipse data (example)
                var radiusX = Math.abs(endX - startX) / 2;
                var radiusY = Math.abs(endY - startY) / 2;
                var centerX = (startX + endX) / 2;
                var centerY = (startY + endY) / 2;

                // Calculate statistical data
                var mean = (radiusX + radiusY) / 2;
                var sd = Math.abs(radiusX - radiusY); // Example for SD calculation
                var max = Math.max(radiusX, radiusY) * 100; // Example max value
                var min = Math.min(radiusX, radiusY) * 10;  // Example min value
                var area = Math.PI * radiusX * radiusY;  // Ellipse area

                // Draw the final ellipse and store it in the ellipses array
                drawEllipseWithData(startX, startY, endX, endY, mean, sd, max, min, area);

                // Store the new ellipse data in the ellipses array for future redrawing
                ellipses.push({ startX, startY, endX, endY, mean, sd, max, min, area });

                console.log("Stored ellipse:", { startX, startY, endX, endY, mean, sd, max, min, area });

                // Reset drawing state
                startX = null;
                startY = null;
                    

            } else if (drawMode === 'rectangle' && selectedRectangle && !selectedRectangle.resizing) {
                // Store the rectangle data after drawing
                endX = event.offsetX;
                endY = event.offsetY;
                rectangles.push({ startX: selectedRectangle.startX, startY: selectedRectangle.startY, endX, endY }); // Store rectangle
                selectedRectangle = null;
                redrawCanvas(); // Redraw the entire canvas
            }
        });
        
        function drawEllipse(x1, y1, x2, y2) {
            var radiusX = Math.abs(x2 - x1) / 2;
            var radiusY = Math.abs(y2 - y1) / 2;
            var centerX = (x1 + x2) / 2;
            var centerY = (y1 + y2) / 2;

            // Store the ellipse data
            ellipses.push({ startX: x1, startY: y1, endX: x2, endY: y2 });
            console.log("Ellipses array after adding ellipse:", ellipses);

            // Draw the ellipse
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2); // Draw ellipse
            ctx.stroke(); // Outline the ellipse

            // Optionally, show ellipse data on the canvas
            displayEllipseData(centerX, centerY, radiusX, radiusY);
        }
        function displayEllipseData(centerX, centerY, radiusX, radiusY) {
            ctx.fillStyle = "#8B0000";
            ctx.font = "14px Arial";
            ctx.fillText(`Center: (${centerX.toFixed(2)}, ${centerY.toFixed(2)})`, centerX + 10, centerY + 10);
            ctx.fillText(`Radius X: ${radiusX.toFixed(2)} px`, centerX + 10, centerY + 25);
            ctx.fillText(`Radius Y: ${radiusY.toFixed(2)} px`, centerX + 10, centerY + 40);
        }


        // Draw the line
        function drawLine(event) {
            if (drawMode === 'draw') {
                ctx.lineTo(event.offsetX, event.offsetY);
                ctx.stroke();
            }
        }
        // Draw an arrow
        function drawDashedArrow(startX, startY, endX, endY) {
            var angle = Math.atan2(endY - startY, endX - startX); // Angle for the line
            var arrowSize = 10; // Size of the arrowhead
            var dashLength = 5; // Length of the dashes
            var gapLength = 5; // Gap between dashes

            

            // Draw dashed line
            ctx.beginPath();
            ctx.setLineDash([dashLength, gapLength]); // Create a dashed line
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.setLineDash([]); // Reset to solid line for arrowhead

            // Draw the arrowhead (single line)
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - arrowSize * Math.cos(angle - Math.PI / 6), endY - arrowSize * Math.sin(angle - Math.PI / 6));
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - arrowSize * Math.cos(angle + Math.PI / 6), endY - arrowSize * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }
        function drawRectangle(event) {
            selectedRectangle.endX = event.offsetX;
            selectedRectangle.endY = event.offsetY;

            // Clear canvas and redraw everything
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height);
            redrawCanvas();

            // Draw the rectangle
            ctx.beginPath();
            ctx.rect(selectedRectangle.startX, selectedRectangle.startY, selectedRectangle.endX - selectedRectangle.startX, selectedRectangle.endY - selectedRectangle.startY);
            ctx.strokeStyle = 'red';
            ctx.stroke();

            // Show rectangle details
            var width = Math.abs(selectedRectangle.endX - selectedRectangle.startX);
            var height = Math.abs(selectedRectangle.endY - selectedRectangle.startY);
            var area = (width * height) / (96 * 96); // Assuming 96 DPI, convert to cm²

            ctx.fillStyle = "yellow";
            ctx.font = "14px Arial";
            ctx.fillText(`Width: ${width}px`, selectedRectangle.startX + 5, selectedRectangle.startY - 5);
            ctx.fillText(`Height: ${height}px`, selectedRectangle.startX + 5, selectedRectangle.startY + 15);
            ctx.fillText(`Area: ${area.toFixed(3)} cm²`, selectedRectangle.startX + 5, selectedRectangle.startY + 35);

            // Draw the resize corners
            drawResizeCorners(selectedRectangle);
        }
        function drawResizeCorners(rect) {
            const size = 3;
            ctx.fillStyle = 'blue';

            // Draw corners
            ctx.beginPath();
            ctx.arc(rect.startX, rect.startY, size, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(rect.endX, rect.startY, size, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(rect.startX, rect.endY, size, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(rect.endX, rect.endY, size, 0, Math.PI * 2);
            ctx.fill();
        }
        function resizeRectangle(event) {
            if (selectedRectangle.resizing) {
                selectedRectangle.endX = event.offsetX;
                selectedRectangle.endY = event.offsetY;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height);
                redrawCanvas(); // Redraw after resizing
            }
        }
        function isNearCorner(event, rect) {
            const tolerance = 10; // Tolerance for detecting clicks near the corners
            return (
                Math.abs(event.offsetX - rect.startX) < tolerance && Math.abs(event.offsetY - rect.startY) < tolerance ||
                Math.abs(event.offsetX - rect.endX) < tolerance && Math.abs(event.offsetY - rect.startY) < tolerance ||
                Math.abs(event.offsetX - rect.startX) < tolerance && Math.abs(event.offsetY - rect.endY) < tolerance ||
                Math.abs(event.offsetX - rect.endX) < tolerance && Math.abs(event.offsetY - rect.endY) < tolerance
            );
        }

        // Erase rectangle logic
        function eraseRectangle(event) {
            for (let i = 0; i < rectangles.length; i++) {
                let rect = rectangles[i];
                if (event.offsetX >= rect.startX && event.offsetX <= rect.endX && event.offsetY >= rect.startY && event.offsetY <= rect.endY) {
                    rectangles.splice(i, 1); // Remove the rectangle from array
                    redrawCanvas(); // Redraw the canvas without the erased rectangle
                    break;
                }
            }
        }


       
        var dpi = 96;  // Standard screen DPI (for most monitors)

        
        var distanceMarkers = []; // Array to store distance markers

        // Add distance marker
        function calculateDistance(x1, y1, x2, y2) {
            var dx = x2 - x1;
            var dy = y2 - y1;
            var distanceInPixels = Math.sqrt(dx * dx + dy * dy); // Distance in pixels
            var distanceInMM = (distanceInPixels / dpi) * 25.4; // Convert pixels to millimeters
            displayDistance(distanceInMM.toFixed(2), x2, y2); // Display distance in mm

            // Store the distance marker
            distanceMarkers.push({ distance: distanceInMM, x: x2, y: y2 });
        }

        // Function to display the distance on the canvas (in mm)
        function displayDistance(distance, x, y) {
            ctx.fillStyle = "red";
            ctx.font = "14px Arial";

            // Display the distance in mm
            ctx.fillText(distance + " mm", x, y);
        }


        // Erase a specific line if clicked
        function eraseSpecificLine(event) {
            var clickX = event.offsetX;
            var clickY = event.offsetY;
            var tolerance = 10; // Set a tolerance for selecting a line (in px)

            // Loop through each line and check if the click is close to the line
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                var lineStartX = line.startX;
                var lineStartY = line.startY;
                var lineEndX = line.endX;
                var lineEndY = line.endY;

                // Check if click is within the tolerance area of the line
                if (isPointNearLine(clickX, clickY, lineStartX, lineStartY, lineEndX, lineEndY, tolerance)) {
                    // Erase the line from the lines array
                    lines.splice(i, 1); // Remove the line from the lines array
                    redrawCanvas(); // Redraw the remaining lines
                    break; // Exit the loop after erasing the line
                }
            }
            for (var i = 0; i < ellipses.length; i++) {
                var ellipse = ellipses[i];
                var ellipseStartX = ellipse.startX;
                var ellipseStartY = ellipse.startY;
                var ellipseEndX = ellipse.endX;
                var ellipseEndY = ellipse.endY;

                // Check if the click is inside the ellipse (simplified approach)
                if (isPointNearEllipse(clickX, clickY, ellipseStartX, ellipseStartY, ellipseEndX, ellipseEndY, tolerance)) {
                    ellipses.splice(i, 1); // Remove the ellipse from the array
                    redrawCanvas(); // Redraw the remaining shapes
                    break;
                }
            }
        }
        // Function to check if a point is near a line (based on tolerance)
        function isPointNearLine(px, py, x1, y1, x2, y2, tolerance) {
            var dist = Math.abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) /
                    Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
            return dist <= tolerance;
        }
        // Function to check if a point is inside an ellipse (based on tolerance)
        function isPointNearEllipse(px, py, x1, y1, x2, y2, tolerance) {
            var centerX = (x1 + x2) / 2;
            var centerY = (y1 + y2) / 2;
            var radiusX = Math.abs(x2 - x1) / 2;
            var radiusY = Math.abs(y2 - y1) / 2;

            // Use the ellipse equation to check if the point is inside the ellipse
            var dx = (px - centerX) / radiusX;
            var dy = (py - centerY) / radiusY;
            var distance = dx * dx + dy * dy;

            return distance <= 1 + tolerance; // Check if the distance is within the tolerance
        }


        
        function redrawCanvas() {
            console.log("Clearing canvas to redraw all elements...");
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear the canvas to avoid any old data remaining

            console.log("Redrawing the base image...");
            ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height);  // Redraw the base image

            // Reset the isEllipseAdded flag here to allow drawing new ellipses
            isEllipseAdded = false;  // Reset the flag after clearing the canvas

            // Debugging: Log the number of lines, ellipses, and rectangles before redrawing
            console.log("Redrawing lines... Total lines:", lines.length);
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                console.log(`Redrawing line ${i}:`, line);
                if (line.type !== 'arrow') {  // If it's not an arrow, draw a regular line
                    ctx.beginPath();
                    ctx.moveTo(line.startX, line.startY);
                    ctx.lineTo(line.endX, line.endY);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                if (line.type === 'arrow') {
                    console.log(`Redrawing arrow ${i}:`, line);
                    drawDashedArrow(line.startX, line.startY, line.endX, line.endY);
                }
            }

            console.log("Redrawing ellipses... Total ellipses before redrawing:", ellipses.length);
            for (var i = 0; i < ellipses.length; i++) {
                var ellipse = ellipses[i];
                console.log(`Redrawing ellipse ${i}:`, ellipse);
                
                // Use drawEllipseWithData to ensure data is displayed with the ellipse
                drawEllipseWithData(ellipse.startX, ellipse.startY, ellipse.endX, ellipse.endY, 
                                    ellipse.mean, ellipse.sd, ellipse.max, ellipse.min, ellipse.area);
            }

            console.log("Redrawing rectangles... Total rectangles:", rectangles.length);
            for (let i = 0; i < rectangles.length; i++) {
                let rect = rectangles[i];
                console.log(`Redrawing rectangle ${i}:`, rect);  // Log the data of each rectangle being drawn
                ctx.beginPath();
                ctx.rect(rect.startX, rect.startY, rect.endX - rect.startX, rect.endY - rect.startY);
                ctx.strokeStyle = 'red'; // Set the rectangle color to red
                ctx.lineWidth = 2;  // Set line width for better visibility
                ctx.stroke();
                var width = Math.abs(rect.endX - rect.startX);
                var height = Math.abs(rect.endY - rect.startY);
                var area = (width * height) / (96 * 96); // Assuming 96 DPI

                ctx.fillStyle = "brown";
                ctx.font = "14px Arial";
                ctx.fillText(`Width: ${width}px`, rect.startX + 5, rect.startY - 5);
                ctx.fillText(`Height: ${height}px`, rect.startX + 5, rect.startY + 15);
                ctx.fillText(`Area: ${area.toFixed(3)} cm²`, rect.startX + 5, rect.startY + 35);
            }
            console.log("Redrawing polygons... Total polygons:", polygons.length);
            for (var i = 0; i < polygons.length; i++) {
                var polygon = polygons[i];
                console.log(`Redrawing polygon ${i}:`, polygon);
                drawPolygon(polygon);  // Draw the polygon
                calculatePolygonArea(polygon); // Display the area for each polygon
            }

            console.log("Canvas redrawn successfully.");
        }




        // Zoom logic
        function toggleZoomMenu() {
            var zoomMenu = document.getElementById("zoom-menu"); // Correct variable name
            var rulerMenu = document.getElementById("ruler-menu");
            var rotateMenu = document.getElementById("rotate-menu");

            // If the zoom menu is open, close it, otherwise open it
            // Hide other menus if they are open
            rulerMenu.style.display = "none";
            rotateMenu.style.display = "none";

            // Toggle the zoom menu
            zoomMenu.style.display = (zoomMenu.style.display === "block") ? "none" : "block";
        }


        

        // Initialize the original width and height (these are the original dimensions of the image).
        

        function setZoom100() {
            var mainImageElement = document.getElementById("main-image");
            
            // Get the original image's natural width and height
            var originalWidth = mainImageElement.naturalWidth;
            var originalHeight = mainImageElement.naturalHeight;

            // Apply the original width and height
            mainImageElement.style.width = originalWidth + "px";
            mainImageElement.style.height = originalHeight + "px";

            // Update canvas size to match the resized image
            var canvas = document.getElementById('canvas');
            canvas.width = originalWidth;
            canvas.height = originalHeight;

            // Redraw the image and any drawn elements on the canvas
            var ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear canvas before redrawing
            ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height);  // Redraw image
            redrawCanvas();  // Redraw any existing lines, ellipses, etc.

            console.log("Zoom set to 100%. Image width: " + originalWidth + "px, Image height: " + originalHeight + "px");
        }
        function setZoom200() {
            var mainImageElement = document.getElementById("main-image");

            // Get the original image's natural width and height
            var originalWidth = mainImageElement.naturalWidth;
            var originalHeight = mainImageElement.naturalHeight;

            // Calculate new width and height (200% of the original size)
            var newWidth = originalWidth * 2;
            var newHeight = originalHeight * 2;

            // Apply the new width and height
            mainImageElement.style.width = newWidth + "px";
            mainImageElement.style.height = newHeight + "px";

            // Update canvas size to match the resized image
            var canvas = document.getElementById('canvas');
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Redraw the image and any drawn elements on the canvas
            var ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear canvas before redrawing
            ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height);  // Redraw image
            redrawCanvas();  // Redraw any existing lines, ellipses, etc.

            console.log("Zoom set to 200%. Image width: " + newWidth + "px, Image height: " + newHeight + "px");
        }
        function setZoom400() {
            var mainImageElement = document.getElementById("main-image");

            // Get the original image's natural width and height
            var originalWidth = mainImageElement.naturalWidth;
            var originalHeight = mainImageElement.naturalHeight;

            // Calculate new width and height (400% of the original size)
            var newWidth = originalWidth * 4;
            var newHeight = originalHeight * 4;

            // Apply the new width and height
            mainImageElement.style.width = newWidth + "px";
            mainImageElement.style.height = newHeight + "px";

            // Update canvas size to match the resized image
            var canvas = document.getElementById('canvas');
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Redraw the image and any drawn elements on the canvas
            var ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear canvas before redrawing
            ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height);  // Redraw image
            redrawCanvas();  // Redraw any existing lines, ellipses, etc.

            console.log("Zoom set to 400%. Image width: " + newWidth + "px, Image height: " + newHeight + "px");
        }
        function setZoom800() {
            var mainImageElement = document.getElementById("main-image");

            // Get the original image's natural width and height
            var originalWidth = mainImageElement.naturalWidth;
            var originalHeight = mainImageElement.naturalHeight;

            // Calculate new width and height (800% of the original size)
            var newWidth = originalWidth * 8;
            var newHeight = originalHeight * 8;

            // Apply the new width and height
            mainImageElement.style.width = newWidth + "px";
            mainImageElement.style.height = newHeight + "px";

            // Update canvas size to match the resized image
            var canvas = document.getElementById('canvas');
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Redraw the image and any drawn elements on the canvas
            var ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear canvas before redrawing
            ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height);  // Redraw image
            redrawCanvas();  // Redraw any existing lines, ellipses, etc.

            console.log("Zoom set to 800%. Image width: " + newWidth + "px, Image height: " + newHeight + "px");
        }







        // Optional: Add zoom-in and zoom-out buttons for demonstration
        function zoomIn() {
            var mainImageElement = document.getElementById("main-image");
            
            // Get the current dimensions of the image
            var currentWidth = mainImageElement.width;
            var currentHeight = mainImageElement.height;

            // Define the pixel increment (20px)
            var zoomIncrement = 20;

            // Calculate new width and height
            var newWidth = currentWidth + zoomIncrement;
            var newHeight = currentHeight + zoomIncrement;

            // Set the new width and height
            mainImageElement.style.width = newWidth + "px";
            mainImageElement.style.height = newHeight + "px";

            // Update canvas size to match the resized image
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Redraw the image and any drawn elements on the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear canvas before redrawing
            ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height);  // Redraw image
            redrawCanvas();  // Redraw all lines, ellipses, etc.
            
            console.log("Zooming in... New width: " + newWidth + "px, New height: " + newHeight + "px");
        }


        function zoomOut() {
            var mainImageElement = document.getElementById("main-image");
            
            // Get the current dimensions of the image
            var currentWidth = mainImageElement.width;
            var currentHeight = mainImageElement.height;

            // Define the pixel decrement (20px)
            var zoomDecrement = 20;

            // Calculate new width and height
            var newWidth = currentWidth - zoomDecrement;
            var newHeight = currentHeight - zoomDecrement;

            // Ensure the image doesn't shrink below a certain size (e.g., 100px)
            if (newWidth < 100) newWidth = 100;
            if (newHeight < 100) newHeight = 100;

            // Set the new width and height
            mainImageElement.style.width = newWidth + "px";
            mainImageElement.style.height = newHeight + "px";

            // Update canvas size to match the resized image
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Redraw the image and any drawn elements on the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear canvas before redrawing
            ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height);  // Redraw image
            redrawCanvas();  // Redraw all lines, ellipses, etc.

            console.log("Zooming out... New width: " + newWidth + "px, New height: " + newHeight + "px");
        }


        

        // Toggle Ruler Menu visibility
        function toggleRulerMenu() {
            var zoomMenu = document.getElementById("zoom-menu");
            var rulerMenu = document.getElementById("ruler-menu");

            var rotateMenu = document.getElementById("rotate-menu");

            // Hide other menus if they are open
            zoomMenu.style.display = "none";
            rotateMenu.style.display = "none";

            // Toggle the ruler menu
            rulerMenu.style.display = (rulerMenu.style.display === "block") ? "none" : "block";
        }
        
        function downloadImage() {
            console.log("Download button clicked");
            

            var canvas = document.getElementById('canvas');
            var ctx = canvas.getContext('2d');

            // First, clear the canvas to avoid any old data remaining
            console.log("Clearing canvas...");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            console.log("Canvas cleared");

            // Redraw the base image on the canvas
            console.log("Redrawing base image...");
            ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height);
            console.log("Base image redrawn");

            // Debugging the arrays to check their data
            console.log("Lines array before redrawing:", lines);
            console.log("Ellipses array before redrawing:", ellipses);
            console.log("Rectangles array before redrawing:", rectangles);

            // Redraw all elements (lines, ellipses, rectangles) on the canvas
            redrawCanvas();

            console.log("Image with lines, ellipses, and rectangles redrawn");
            for (var i = 0; i < distanceMarkers.length; i++) {
                var marker = distanceMarkers[i];
                console.log(`Redrawing distance marker ${i}:`, marker);  // Log the data of each distance marker
                displayDistance(marker.distance, marker.x, marker.y);
            }


            // Export the current content of the canvas (which includes both the image and the drawings)
            var imageURL = canvas.toDataURL("image/png");
            console.log("Image URL generated");

            // Create a temporary link element to trigger the download
            var link = document.createElement('a');
            link.href = imageURL;  // Set the href to the image data
            link.download = 'image_with_drawings.png';  // Set the default filename
            console.log("Download link created");

            // Trigger the click event to download the image
            link.click();
            console.log("Download triggered");
        }

        function toggleRotateMenu() {
            var rotateMenu = document.getElementById("rotate-menu");
            var zoomMenu = document.getElementById("zoom-menu");
            var rulerMenu = document.getElementById("ruler-menu");

            // Hide other menus if they are open
            zoomMenu.style.display = "none";
            rulerMenu.style.display = "none";

            // Toggle the rotate menu
            rotateMenu.style.display = (rotateMenu.style.display === "none" || rotateMenu.style.display === "") ? "block" : "none";
        }
        function rotateImage() {
            var mainImageElement = document.getElementById("main-image");

            // Increment the rotation by 90 degrees
            currentRotation += 90;
            
            // Keep the rotation value between 0-360 degrees
            if (currentRotation >= 360) {
                currentRotation = 0; // Reset to 0 degrees after a full rotation
            }

            // Apply the rotation to the image element
            mainImageElement.style.transform = "rotate(" + currentRotation + "deg)";

            // Ensure the canvas rotates as well, maintaining alignment
            var canvas = document.getElementById('canvas');
            canvas.style.transform = "rotate(" + currentRotation + "deg)"; // Same rotation for canvas
        }
        function rotateImageAnticlockwise() {
            var mainImageElement = document.getElementById("main-image");

            // Decrement the rotation by 90 degrees (anticlockwise)
            currentRotation -= 90;

            // Keep the rotation value between 0 and 360 degrees
            if (currentRotation < 0) {
                currentRotation = 270; // Set to 270 degrees if the value goes below 0
            }

            // Apply the rotation to the image element
            mainImageElement.style.transform = "rotate(" + currentRotation + "deg)";

            // Ensure the canvas rotates as well, maintaining alignment
            var canvas = document.getElementById('canvas');
            canvas.style.transform = "rotate(" + currentRotation + "deg)"; // Same rotation for canvas
        }
        function rotateImage180() {
            var mainImageElement = document.getElementById("main-image");

            // Set the rotation to 180 degrees
            currentRotation = (currentRotation + 180) % 360;

            // Apply the rotation to the image element
            mainImageElement.style.transform = "rotate(" + currentRotation + "deg)";

            // Ensure the canvas rotates as well, maintaining alignment
            var canvas = document.getElementById('canvas');
            canvas.style.transform = "rotate(" + currentRotation + "deg)"; // Same rotation for canvas
        }
        function flipHorizontal() {
            var mainImageElement = document.getElementById("main-image");

            // Toggle the flip state
            if (isFlipped) {
                mainImageElement.style.transform = "scaleX(1)"; // Restore to original
                var canvas = document.getElementById('canvas');
                canvas.style.transform = "scaleX(1)"; // Restore canvas to original
            } else {
                mainImageElement.style.transform = "scaleX(-1)"; // Flip horizontally
                var canvas = document.getElementById('canvas');
                canvas.style.transform = "scaleX(-1)"; // Apply same flip to canvas
            }

            // Update the flip state
            isFlipped = !isFlipped;
        }
        function flipVertical() {
            var mainImageElement = document.getElementById("main-image");

            // Set the rotation to 180 degrees
            currentRotation = (currentRotation + 180) % 360;

            // Apply the rotation to the image element
            mainImageElement.style.transform = "rotate(" + currentRotation + "deg)";

            // Ensure the canvas rotates as well, maintaining alignment
            var canvas = document.getElementById('canvas');
            canvas.style.transform = "rotate(" + currentRotation + "deg)"; // Same rotation for canvas
        }
        {% comment %} function clearTransformations() {
            var mainImageElement = document.getElementById("main-image");

            // Reset to original position and reset rotation
            currentRotation = 0; // Reset rotation to 0 degrees
            isFlipped = false;   // Reset flip state

            // Clear all transformations
            mainImageElement.style.transition = "transform 0.3s";
            mainImageElement.style.transform = "rotate(0deg) scaleX(1) scaleY(1)"; // Reset to original position, no flips or rotations

            // Reset canvas to match
            var canvas = document.getElementById('canvas');
            canvas.style.transition = "transform 0.3s";
            canvas.style.transform = "rotate(0deg) scaleX(1) scaleY(1)"; // Reset canvas to original position

            console.log("All transformations cleared. Image and canvas are back to original position.");
        } {% endcomment %}
        function drawEllipseWithData(x1, y1, x2, y2, mean, sd, max, min, area) {
            var centerX = (x1 + x2) / 2;
            var centerY = (y1 + y2) / 2;

            // Calculate the radii for ellipse based on the start and end coordinates
            var radiusX = Math.abs(x2 - x1) / 2;
            var radiusY = Math.abs(y2 - y1) / 2;

            // Draw the ellipse
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2); // Draw ellipse
            ctx.strokeStyle = "green";  // Set the ellipse border color to green
            ctx.lineWidth = 2; // Optional: set line width to make it thicker if needed
            ctx.stroke(); // Outline the ellipse

            // Display the data (Mean, SD, Max, Min, Area) near the ellipse
            displayEllipseData(centerX, centerY, radiusX, radiusY, mean, sd, max, min, area);
        }

        let hoveredText = null;  // Store the hovered text element
        function displayEllipseData(centerX, centerY, radiusX, radiusY, mean, sd, max, min, area) {
            ctx.fillStyle = "yellow";  // Text color
            ctx.font = "14px Arial";
            
            // Calculate text width and height to fit the background rectangle around the text
            var text1 = `Mean: ${mean.toFixed(2)} SD: ${sd.toFixed(2)}`;
            var text2 = `Max: ${max.toFixed(2)} Min: ${min.toFixed(2)}`;
            var text3 = `Area: ${area.toFixed(3)} cm²`;
            

            var textWidth = Math.max(ctx.measureText(text1).width, ctx.measureText(text2).width, 
                                    ctx.measureText(text3).width);
            
            var textHeight = 3 * 14;  // 14px per line, and 5 lines in total

            // Set the background color
            ctx.fillStyle = "rgba(104, 56, 56, 0.6)";  // Semi-transparent black background
            ctx.fillRect(centerX + 10, centerY + 10, textWidth + 20, textHeight + 10);  // Draw background rectangle

            // Displaying ellipse data on the canvas
            ctx.fillStyle = "yellow";  // Text color
            ctx.fillText(text1, centerX + 20, centerY + 30);
            ctx.fillText(text2, centerX + 20, centerY + 45);
            ctx.fillText(text3, centerX + 20, centerY + 60);
            
        }
        // Function to draw the points as circles on the canvas
        function drawPoint(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2, false); // Create a circle with radius 5
            ctx.fillStyle = "yellow"; // Fill color for the point
            ctx.fill(); // Fill the circle
            ctx.stroke(); // Optional: to outline the circle
        }
        // Function to draw the polygon as the user clicks
        function drawPolygonPreview() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear the canvas
            ctx.drawImage(mainImageElement, 0, 0, canvas.width, canvas.height); // Redraw image
            redrawCanvas(); // Redraw existing shapes

            // Draw the polygon preview by connecting the points
            ctx.beginPath();
            ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
            for (var i = 1; i < polygonPoints.length; i++) {
                ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
            }
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw the points
            for (var i = 0; i < polygonPoints.length; i++) {
                drawPoint(polygonPoints[i].x, polygonPoints[i].y); // Draw each point
            }
        }
        // Function to draw the final polygon
        function drawPolygon(points) {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (var i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.lineTo(points[0].x, points[0].y); // Close the polygon
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Function to calculate the area of the polygon (using the Shoelace Theorem)
        function calculatePolygonArea(points) {
            var area = 0;
            var n = points.length;

            for (var i = 0; i < n; i++) {
                var j = (i + 1) % n; // Next point index
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            area = Math.abs(area) / 2; // Final area
            displayPolygonData(points, area);
        }

        // Function to display polygon area and other data on the canvas
        function displayPolygonData(points, area) {
            var centerX = 0;
            var centerY = 0;
            for (var i = 0; i < points.length; i++) {
                centerX += points[i].x;
                centerY += points[i].y;
            }
            centerX /= points.length;
            centerY /= points.length;

            ctx.fillStyle = "yellow";
            ctx.font = "14px Arial";
            ctx.fillText(`Area: ${area.toFixed(2)} cm²`, centerX + 10, centerY + 10);
        }












            
    </script>

    <!-- Bootstrap JS (for dropdown functionality) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

</body>
</html>
